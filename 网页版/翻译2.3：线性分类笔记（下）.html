<html>
<head>
  <title>翻译2.3：线性分类笔记（下）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/305512 (zh-CN, DDL); Windows/10.0.15063 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1555"/>
<h1>翻译2.3：线性分类笔记（下）</h1>

<div>
<span><div style="-evernote-webclip:true"><div><span><span style="font-family: inherit; font-size: 24px; font-style: inherit; font-variant: inherit; font-weight: 700; line-height: inherit; color: rgb(51, 51, 51);">原文如下</span><br/></span></div><div style="font-size: 16px; display: inline-block;"><div style="box-sizing:border-box;"><div style="box-sizing:inherit;overflow-x:hidden;font-family:-apple-system, &quot;Helvetica Neue&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;font-weight:400;font-style:normal;text-rendering:optimizeLegibility;line-height:1;color:rgb(51, 51, 51);"><div style="box-sizing:inherit;flex-direction:column;align-items:stretch;flex-shrink:0;"><div style="box-sizing:inherit;flex-direction:column;align-items:stretch;flex-shrink:0;"><div style="box-sizing:inherit;flex-direction:column;align-items:stretch;flex-shrink:0;background:rgb(255, 255, 255);"><div style="box-sizing:inherit;flex-direction:column;align-items:stretch;flex-shrink:0;"><div style="box-sizing:inherit;flex-direction:column;align-items:stretch;flex-shrink:0;display:block;word-break:break-word;white-space:normal;margin:30px 0px;line-height:1.7;"><p style="box-sizing:inherit;margin:20px 0px;">内容列表：</p><ul style="box-sizing:inherit;padding:0px;margin:20px 0px;padding-left:40px;"><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;">线性分类器简介</li><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;">线性评分函数</li><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;">阐明线性分类器</li><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;">损失函数</li><ul style="box-sizing:inherit;padding:0px;padding-left:40px;margin:0px;"><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;">多类SVM</li><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;">Softmax分类器 <i style="box-sizing:inherit;"><b style="box-sizing:inherit;font-weight:700;">译者注：下篇翻译起始处</b></i></li><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;">SVM和Softmax的比较</li></ul><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;">基于Web的可交互线性分类器原型</li><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;">小结</li></ul><h2 style="box-sizing:inherit;font-style:inherit;font-variant:inherit;font-stretch:inherit;line-height:inherit;font-family:inherit;margin:20px 0px;font-size:24px;font-weight:700;">Softmax分类器</h2><p style="box-sizing:inherit;margin:20px 0px;">SVM是最常用的两个分类器之一，而另一个就是<strong style="box-sizing:inherit;">Softmax分类器，</strong>它的损失函数与SVM的损失函数不同。对于学习过二元逻辑回归分类器的读者来说，Softmax分类器就可以理解为逻辑回归分类器面对多个分类的一般化归纳。SVM将输出<img src="翻译2.3：线性分类笔记（下）_files/equation.png" type="image/png" data-filename="equation.png" alt="f(x_i,W)" height="18" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="60"/>作为每个分类的评分（因为无定标，所以难以直接解释）。与SVM不同，Softmax的输出（归一化的分类概率）更加直观，并且从概率上可以解释，这一点后文会讨论。在Softmax分类器中，函数映射<img src="翻译2.3：线性分类笔记（下）_files/equation [1].png" type="image/png" data-filename="equation.png" alt="f(x_i;W)=Wx_i" height="18" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="114"/>保持不变，但将这些评分值视为每个分类的未归一化的对数概率，并且将<i style="box-sizing:inherit;">折叶损失（hinge loss）</i>替换为<b style="box-sizing:inherit;font-weight:700;">交叉熵损失</b>（<strong style="box-sizing:inherit;">cross-entropy loss）</strong>。公式如下：</p><p style="box-sizing:inherit;margin:20px 0px;"><img src="翻译2.3：线性分类笔记（下）_files/equation [2].png" type="image/png" data-filename="equation.png" alt="\displaystyle Li=-log(\frac{e^{f_{y_i}}}{\sum_je^{f_j}})" height="44" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="134"/> 或等价的 <img src="翻译2.3：线性分类笔记（下）_files/equation [3].png" type="image/png" data-filename="equation.png" alt="L_i=-f_{y_i}+log(\sum_je^{f_j})" height="37" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="168"/></p><p style="box-sizing:inherit;margin:20px 0px;"></p><div>在上式中，使用<img src="翻译2.3：线性分类笔记（下）_files/equation [4].png" type="image/png" data-filename="equation.png" alt="f_j" height="16" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="13"/>来表示分类评分向量<img src="翻译2.3：线性分类笔记（下）_files/equation [5].png" type="image/png" data-filename="equation.png" alt="f" height="14" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="10"/>中的第j个元素。和之前一样，整个数据集的损失值是数据集中所有样本数据的损失值<img src="翻译2.3：线性分类笔记（下）_files/equation [6].png" type="image/png" data-filename="equation.png" alt="L_i" height="14" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="15"/>的均值与正则化损失<img src="翻译2.3：线性分类笔记（下）_files/equation [7].png" type="image/png" data-filename="equation.png" alt="R(W)" height="18" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="42"/>之和。其中函数<img src="翻译2.3：线性分类笔记（下）_files/equation [8].png" type="image/png" data-filename="equation.png" alt="f_j(z)=\frac{e^{z_j}}{\sum_ke^{z_k}}" height="39" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="106"/>被称作<strong style="box-sizing:inherit;">softmax 函数</strong>：其输入值是一个向量，向量中元素为任意实数的评分值（<img src="翻译2.3：线性分类笔记（下）_files/equation [9].png" type="image/png" data-filename="equation.png" alt="z" height="7" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="8"/>中的），函数对其进行压缩，输出一个向量，其中每个元素值在0到1之间，且所有元素之和为1。所以，包含softmax函数的完整交叉熵损失看起唬人，实际上还是比较容易理解的。</div><p style="box-sizing:inherit;margin:20px 0px;"></p><div><strong style="box-sizing:inherit;">信息理论视角</strong>：在“真实”分布<img src="翻译2.3：线性分类笔记（下）_files/equation [10].png" type="image/png" data-filename="equation.png" alt="p" height="10" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="9"/>和估计分布<img src="翻译2.3：线性分类笔记（下）_files/equation [11].png" type="image/png" data-filename="equation.png" alt="q" height="10" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="8"/>之间的<i style="box-sizing:inherit;">交叉熵</i>定义如下：</div><div><img src="翻译2.3：线性分类笔记（下）_files/equation [12].png" type="image/png" data-filename="equation.png" alt="\displaystyle H(p,q)=-\sum_xp(x) logq(x)" height="34" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="194"/></div><p style="box-sizing:inherit;margin:20px 0px;">因此，Softmax分类器所做的就是最小化在估计分类概率（就是上面的<img src="翻译2.3：线性分类笔记（下）_files/equation [13].png" type="image/png" data-filename="equation.png" alt="e^{f_{y_i}}/\sum_je^{f_j}" height="37" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="80"/>）和“真实”分布之间的交叉熵，在这个解释中，“真实”分布就是所有概率密度都分布在正确的类别上（比如：<img src="翻译2.3：线性分类笔记（下）_files/equation [14].png" type="image/png" data-filename="equation.png" alt="p=[0,...1,...,0]" height="18" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="112"/>中在<img src="翻译2.3：线性分类笔记（下）_files/equation [15].png" type="image/png" data-filename="equation.png" alt="y_i" height="10" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="12"/>的位置就有一个单独的1）。还有，既然交叉熵可以写成熵和相对熵（Kullback-Leibler divergence）<img src="翻译2.3：线性分类笔记（下）_files/equation [16].png" type="image/png" data-filename="equation.png" alt="H(p,q)=H(p)+D_{KL}(p||q)" height="18" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="198"/>，并且delta函数<img src="翻译2.3：线性分类笔记（下）_files/equation [17].png" type="image/png" data-filename="equation.png" alt="p" height="10" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="9"/>的熵是0，那么就能等价的看做是对两个分布之间的相对熵做最小化操作。换句话说，交叉熵损失函数“想要”预测分布的所有<u style="box-sizing:inherit;text-decoration:none;border-bottom:1px solid rgba(64, 64, 64, 0.72);">概率密度</u>都在正确分类上。</p><p style="box-sizing:inherit;margin:20px 0px;"><i style="box-sizing:inherit;"><b style="box-sizing:inherit;font-weight:700;">译者注</b>：Kullback-Leibler差异（Kullback-Leibler Divergence）也叫做相对熵（Relative Entropy），它衡量的是相同事件空间里的两个概率分布的差异情况。</i></p><p style="box-sizing:inherit;margin:20px 0px;"></p><div><strong style="box-sizing:inherit;">概率论解释</strong>：先看下面的公式：</div><div><img src="翻译2.3：线性分类笔记（下）_files/equation [18].png" type="image/png" data-filename="equation.png" alt="P(y_i|x_i,W)=\frac{e^{f_{y_i}}}{\sum_je^{f_j}}" height="44" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="151"/></div><p style="box-sizing:inherit;margin:20px 0px;">可以解释为是给定图像数据<img src="翻译2.3：线性分类笔记（下）_files/equation [19].png" type="image/png" data-filename="equation.png" alt="x_i" height="10" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="13"/>，以<img src="翻译2.3：线性分类笔记（下）_files/equation [20].png" type="image/png" data-filename="equation.png" alt="W" height="11" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="18"/>为参数，分配给正确分类标签<img src="翻译2.3：线性分类笔记（下）_files/equation [21].png" type="image/png" data-filename="equation.png" alt="y_i" height="10" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="12"/>的归一化概率。为了理解这点，请回忆一下Softmax分类器将输出向量<img src="翻译2.3：线性分类笔记（下）_files/equation [22].png" type="image/png" data-filename="equation.png" alt="f" height="14" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="10"/>中的评分值解释为没有归一化的<u style="box-sizing:inherit;text-decoration:none;border-bottom:1px solid rgba(64, 64, 64, 0.72);">对数概率</u>。那么以这些数值做指数函数的幂就得到了没有归一化的概率，而除法操作则对数据进行了归一化处理，使得这些概率的和为1。从概率论的角度来理解，我们就是在最小化正确分类的负对数概率，这可以看做是在进行<i style="box-sizing:inherit;">最大似然估计</i>（MLE）。该解释的另一个好处是，损失函数中的正则化部分<img src="翻译2.3：线性分类笔记（下）_files/equation [23].png" type="image/png" data-filename="equation.png" alt="R(W)" height="18" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="42"/>可以被看做是权重矩阵<img src="翻译2.3：线性分类笔记（下）_files/equation [24].png" type="image/png" data-filename="equation.png" alt="W" height="11" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="18"/>的高斯先验，这里进行的是最大后验估计（MAP）而不是最大似然估计。提及这些解释只是为了让读者形成直观的印象，具体细节就超过本课程范围了。</p><p style="box-sizing:inherit;margin:20px 0px;"><strong style="box-sizing:inherit;">实操事项：数值稳定。</strong>编程实现softmax函数计算的时候，中间项<img src="翻译2.3：线性分类笔记（下）_files/equation [25].png" type="image/png" data-filename="equation.png" alt="e^{f_{y_i}}" height="14" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="23"/>和<img src="翻译2.3：线性分类笔记（下）_files/equation [26].png" type="image/png" data-filename="equation.png" alt="\sum_j e^{f_j}" height="37" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="44"/>因为存在指数函数，所以数值可能非常大。除以大数值可能导致数值计算的不稳定，所以学会使用归一化技巧非常重要。如果在分式的分子和分母都乘以一个常数<img src="翻译2.3：线性分类笔记（下）_files/equation [27].png" type="image/png" data-filename="equation.png" alt="C" height="11" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="13"/>，并把它变换到求和之中，就能得到一个从数学上等价的公式：</p><div><img src="翻译2.3：线性分类笔记（下）_files/equation [28].png" type="image/png" data-filename="equation.png" alt="\frac{e^{f_{y_i}}}{\sum_je^{f_j}}=\frac{Ce^{f_{y_i}}}{C\sum_je^{f_j}}=\frac{e^{f_{y_i}+logC}}{\sum_je^{f_j+logC}}" height="44" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="238"/></div><p style="box-sizing:inherit;margin:20px 0px;"><img src="翻译2.3：线性分类笔记（下）_files/equation [29].png" type="image/png" data-filename="equation.png" alt="C" height="11" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="13"/>的值可自由选择，不会影响计算结果，通过使用这个技巧可以提高计算中的数值稳定性。通常将<img src="翻译2.3：线性分类笔记（下）_files/equation [30].png" type="image/png" data-filename="equation.png" alt="C" height="11" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="13"/>设为<img src="翻译2.3：线性分类笔记（下）_files/equation [31].png" type="image/png" data-filename="equation.png" alt="logC=-max_jf_j" height="16" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="120"/>。该技巧简单地说，就是应该将向量<img src="翻译2.3：线性分类笔记（下）_files/equation [32].png" type="image/png" data-filename="equation.png" alt="f" height="14" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="10"/>中的数值进行平移，使得最大值为0。代码实现如下：</p><div style="box-sizing:inherit;flex-direction:column;align-items:stretch;flex-shrink:0;display:block;"><div style="box-sizing:inherit;margin:1em 0px;padding-right:1em;padding-left:1em;overflow:auto;font-family:Menlo, Monaco, Consolas, &quot;Andale Mono&quot;, &quot;lucida console&quot;, &quot;Courier New&quot;, monospace;font-size:14px;word-wrap:break-word;background:rgb(235, 238, 245);border-radius:4px;"><div><code style="box-sizing:inherit;"><span style="box-sizing:inherit;">f</span> <span style="box-sizing:inherit;font-weight:bold;">=</span> <span style="box-sizing:inherit;">np</span><span style="box-sizing:inherit;font-weight:bold;">.</span><span style="box-sizing:inherit;">array</span><span style="box-sizing:inherit;">([</span><span style="box-sizing:inherit;color:rgb(0, 153, 153);">123</span><span style="box-sizing:inherit;">,</span> <span style="box-sizing:inherit;color:rgb(0, 153, 153);">456</span><span style="box-sizing:inherit;">,</span> <span style="box-sizing:inherit;color:rgb(0, 153, 153);">789</span><span style="box-sizing:inherit;">])</span> <span style="box-sizing:inherit;font-style:italic;color:rgb(153, 153, 136);"># 例子中有3个分类，每个评分的数值都很大</span></code></div><div><code style="box-sizing:inherit;"><span style="box-sizing:inherit;">p</span> <span style="box-sizing:inherit;font-weight:bold;">=</span> <span style="box-sizing:inherit;">np</span><span style="box-sizing:inherit;font-weight:bold;">.</span><span style="box-sizing:inherit;">exp</span><span style="box-sizing:inherit;">(</span><span style="box-sizing:inherit;">f</span><span style="box-sizing:inherit;">)</span> <span style="box-sizing:inherit;font-weight:bold;">/</span> <span style="box-sizing:inherit;">np</span><span style="box-sizing:inherit;font-weight:bold;">.</span><span style="box-sizing:inherit;">sum</span><span style="box-sizing:inherit;">(</span><span style="box-sizing:inherit;">np</span><span style="box-sizing:inherit;font-weight:bold;">.</span><span style="box-sizing:inherit;">exp</span><span style="box-sizing:inherit;">(</span><span style="box-sizing:inherit;">f</span><span style="box-sizing:inherit;">))</span> <span style="box-sizing:inherit;font-style:italic;color:rgb(153, 153, 136);"># 不妙：数值问题，可能导致数值爆炸</span></code></div><div><br/></div><div><code style="box-sizing:inherit;"><span style="box-sizing:inherit;font-style:italic;color:rgb(153, 153, 136);"># 那么将f中的值平移到最大值为0：</span></code></div><div><code style="box-sizing:inherit;"><span style="box-sizing:inherit;">f</span> <span style="box-sizing:inherit;font-weight:bold;">-=</span> <span style="box-sizing:inherit;">np</span><span style="box-sizing:inherit;font-weight:bold;">.</span><span style="box-sizing:inherit;">max</span><span style="box-sizing:inherit;">(</span><span style="box-sizing:inherit;">f</span><span style="box-sizing:inherit;">)</span> <span style="box-sizing:inherit;font-style:italic;color:rgb(153, 153, 136);"># f becomes [-666, -333, 0]</span></code></div><div><code style="box-sizing:inherit;"><span style="box-sizing:inherit;">p</span> <span style="box-sizing:inherit;font-weight:bold;">=</span> <span style="box-sizing:inherit;">np</span><span style="box-sizing:inherit;font-weight:bold;">.</span><span style="box-sizing:inherit;">exp</span><span style="box-sizing:inherit;">(</span><span style="box-sizing:inherit;">f</span><span style="box-sizing:inherit;">)</span> <span style="box-sizing:inherit;font-weight:bold;">/</span> <span style="box-sizing:inherit;">np</span><span style="box-sizing:inherit;font-weight:bold;">.</span><span style="box-sizing:inherit;">sum</span><span style="box-sizing:inherit;">(</span><span style="box-sizing:inherit;">np</span><span style="box-sizing:inherit;font-weight:bold;">.</span><span style="box-sizing:inherit;">exp</span><span style="box-sizing:inherit;">(</span><span style="box-sizing:inherit;">f</span><span style="box-sizing:inherit;">))</span> <span style="box-sizing:inherit;font-style:italic;color:rgb(153, 153, 136);"># 现在OK了，将给出正确结果</span></code></div></div></div><p style="box-sizing:inherit;margin:20px 0px;"><strong style="box-sizing:inherit;">让人迷惑的命名规则</strong>：精确地说，SVM分类器使用的是<i style="box-sizing:inherit;">折叶损失（hinge loss）</i>，有时候又被称为<i style="box-sizing:inherit;">最大边界损失（max-margin loss）</i>。Softmax分类器使用的是<i style="box-sizing:inherit;">交叉熵损失（corss-entropy loss）</i>。Softmax分类器的命名是从<i style="box-sizing:inherit;">softmax函数</i>那里得来的，softmax函数将原始分类评分变成正的归一化数值，所有数值和为1，这样处理后交叉熵损失才能应用。注意从技术上说“softmax损失（softmax loss）”是没有意义的，因为softmax只是一个压缩数值的函数。但是在这个说法常常被用来做简称。</p><h2 style="box-sizing:inherit;font-style:inherit;font-variant:inherit;font-stretch:inherit;line-height:inherit;font-family:inherit;margin:20px 0px;font-size:24px;font-weight:700;">SVM和Softmax的比较</h2>
下图有助于区分这 Softmax和SVM这两种分类器：
<p style="box-sizing:inherit;margin:20px 0px;">————————————————————————————————————————</p><img src="翻译2.3：线性分类笔记（下）_files/a90ce9e0ff533f3efee4747305382064_b.png" type="image/png" data-filename="a90ce9e0ff533f3efee4747305382064_b.png" height="321" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;display:block;max-width:100%;margin-top:0.72em;margin-bottom:0.72em;cursor:-webkit-zoom-in;" width="1404"/><p style="box-sizing:inherit;margin:20px 0px;">针对一个数据点，SVM和Softmax分类器的不同处理方式的例子。两个分类器都计算了同样的分值向量<b style="box-sizing:inherit;font-weight:700;">f</b>（本节中是通过矩阵乘来实现）。不同之处在于对<b style="box-sizing:inherit;font-weight:700;">f</b>中分值的解释：SVM分类器将它们看做是分类评分，它的损失函数鼓励正确的分类（本例中是蓝色的类别2）的分值比其他分类的分值高出至少一个边界值。Softmax分类器将这些数值看做是每个分类没有归一化的<b style="box-sizing:inherit;font-weight:700;">对数<u style="box-sizing:inherit;text-decoration:none;border-bottom:1px solid rgba(64, 64, 64, 0.72);">概率</u></b>，鼓励正确分类的归一化的对数概率变高，其余的变低。SVM的最终的损失值是1.58，Softmax的最终的损失值是0.452，但要注意这两个数值没有可比性。只在给定同样数据，在同样的分类器的损失值计算中，它们才有意义。</p><p style="box-sizing:inherit;margin:20px 0px;">————————————————————————————————————————</p><p style="box-sizing:inherit;margin:20px 0px;"><strong style="box-sizing:inherit;">Softmax分类器为每个分类提供了“可能性”</strong>：SVM的计算是无标定的，而且难以针对所有分类的评分值给出直观解释。Softmax分类器则不同，它允许我们计算出对于所有分类标签的可能性。举个例子，针对给出的图像，SVM分类器可能给你的是一个[12.5, 0.6, -23.0]对应分类“猫”，“狗”，“船”。而softmax分类器可以计算出这三个标签的”可能性“是[0.9, 0.09, 0.01]，这就让你能看出对于不同分类准确性的把握。为什么我们要在”可能性“上面打引号呢？这是因为可能性分布的集中或离散程度是由正则化参数λ直接决定的，λ是你能直接控制的一个输入参数。举个例子，假设3个分类的原始分数是[1, -2, 0]，那么softmax函数就会计算：</p><div><img src="翻译2.3：线性分类笔记（下）_files/equation [33].png" type="image/png" data-filename="equation.png" alt="[1,-2,0]\to[e^1,e^{-2},e^0]=[2.71,0.14,1]\to[0.7,0.04,0.26]" height="19" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="399"/></div><p style="box-sizing:inherit;margin:20px 0px;"></p><div>现在，如果正则化参数λ更大，那么权重W就会被惩罚的更多，然后他的权重数值就会更小。这样算出来的分数也会更小，假设小了一半吧[0.5, -1, 0]，那么softmax函数的计算就是：</div><div><img src="翻译2.3：线性分类笔记（下）_files/equation [34].png" type="image/png" data-filename="equation.png" alt="[0.5,-1,0]\to[e^{0.5},e^{-1},e^0]=[1.65,0.73,1]\to[0.55,0.12,0.33]" height="19" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="429"/></div><div><br style="box-sizing:inherit;"/></div><p style="box-sizing:inherit;margin:20px 0px;">现在看起来，概率的分布就更加分散了。还有，随着正则化参数λ不断增强，权重数值会越来越小，最后输出的概率会接近于均匀分布。这就是说，softmax分类器算出来的概率最好是看成一种对于分类正确性的自信。和SVM一样，数字间相互比较得出的大小顺序是可以解释的，但其绝对值则难以直观解释<b style="box-sizing:inherit;font-weight:700;">。</b></p><p style="box-sizing:inherit;margin:20px 0px;"><strong style="box-sizing:inherit;">在实际使用中，SVM和Softmax经常是相似的</strong>：通常说来，两种分类器的表现差别很小，不同的人对于哪个分类器更好有不同的看法。相对于Softmax分类器，SVM更加“局部目标化（local objective）”，这既可以看做是一个特性，也可以看做是一个劣势。考虑一个评分是[10, -2, 3]的数据，其中第一个分类是正确的。那么一个SVM（<img src="翻译2.3：线性分类笔记（下）_files/equation [35].png" type="image/png" data-filename="equation.png" alt="\Delta =1" height="13" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;max-width:100%;vertical-align:middle;display:inline-block;margin:0px 3px;" width="42"/>）会看到正确分类相较于不正确分类，已经得到了比边界值还要高的分数，它就会认为损失值是0。SVM对于数字个体的细节是不关心的：如果分数是[10, -100, -100]或者[10, 9, 9]，对于SVM来说没设么不同，只要满足超过边界值等于1，那么损失值就等于0。</p><p style="box-sizing:inherit;margin:20px 0px;">对于softmax分类器，情况则不同。对于[10, 9, 9]来说，计算出的损失值就远远高于[10, -100, -100]的。换句话来说，softmax分类器对于分数是永远不会满意的：正确分类总能得到更高的可能性，错误分类总能得到更低的可能性，损失值总是能够更小。但是，SVM只要边界值被满足了就满意了，不会超过限制去细微地操作具体分数。这可以被看做是SVM的一种特性。举例说来，一个汽车的分类器应该把他的大量精力放在如何分辨小轿车和大卡车上，而不应该纠结于如何与青蛙进行区分，因为区分青蛙得到的评分已经足够低了。</p><h2 style="box-sizing:inherit;font-style:inherit;font-variant:inherit;font-stretch:inherit;line-height:inherit;font-family:inherit;margin:20px 0px;font-size:24px;font-weight:700;">交互式的网页Demo</h2><p style="box-sizing:inherit;margin:20px 0px;">————————————————————————————————————————</p><p style="box-sizing:inherit;margin:20px 0px;"></p><div><img src="翻译2.3：线性分类笔记（下）_files/a68bbfd4465689c6d65b3eae9c24c934_b.jpg" type="image/jpeg" data-filename="a68bbfd4465689c6d65b3eae9c24c934_b.jpg" height="292" style="box-sizing:inherit;overflow:hidden;margin-left:auto;margin-right:auto;display:block;max-width:100%;margin-top:0.72em;margin-bottom:0.72em;cursor:-webkit-zoom-in;" width="776"/>我们实现了一个交互式的网页原型，来帮助读者直观地理解线性分类器。原型将损失函数进行可视化，画面表现的是对于2维数据的3种类别的分类。原型在课程进度上稍微超前，展现了最优化的内容，最优化将在下一节课讨论。</div><p style="box-sizing:inherit;margin:20px 0px;">————————————————————————————————————————</p><h2 style="box-sizing:inherit;font-style:inherit;font-variant:inherit;font-stretch:inherit;line-height:inherit;font-family:inherit;margin:20px 0px;font-size:24px;font-weight:700;">小结</h2><p style="box-sizing:inherit;margin:20px 0px;">总结如下：</p><ul style="box-sizing:inherit;padding:0px;margin:20px 0px;padding-left:40px;"><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;">定义了从图像像素映射到不同类别的分类评分的评分函数。在本节中，评分函数是一个基于权重<b style="box-sizing:inherit;font-weight:700;">W</b>和偏差<b style="box-sizing:inherit;font-weight:700;">b</b>的线性函数。</li><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;">与kNN分类器不同，<b style="box-sizing:inherit;font-weight:700;">参数方法</b>的优势在于一旦通过训练学习到了参数，就可以将训练数据丢弃了。同时该方法对于新的测试数据的预测非常快，因为只需要与权重<b style="box-sizing:inherit;font-weight:700;">W</b>进行一个矩阵乘法运算。</li><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;">介绍了偏差技巧，让我们能够将偏差向量和权重矩阵合二为一，然后就可以只跟踪一个矩阵。</li><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;">定义了损失函数（介绍了SVM和Softmax线性分类器最常用的2个损失函数）。损失函数能够衡量给出的参数集与训练集数据真实类别情况之间的一致性。在损失函数的定义中可以看到，对训练集数据做出良好预测与得到一个足够低的损失值这两件事是等价的。</li></ul><p style="box-sizing:inherit;margin:20px 0px;">现在我们知道了如何基于参数，将数据集中的图像映射成为分类的评分，也知道了两种不同的损失函数，它们都能用来衡量算法分类预测的质量。但是，如何高效地得到能够使损失值最小的参数呢？这个求得最优参数的过程被称为最优化，将在下节课中进行介绍。</p><h2 style="box-sizing:inherit;font-style:inherit;font-variant:inherit;font-stretch:inherit;line-height:inherit;font-family:inherit;margin:20px 0px;font-size:24px;font-weight:700;">拓展阅读</h2><p style="box-sizing:inherit;margin:20px 0px;">下面的内容读者可根据兴趣选择性阅读。</p><ul style="box-sizing:inherit;padding:0px;margin:20px 0px;padding-left:40px;"><li style="box-sizing:inherit;margin-top:10px;list-style-type:initial;list-style-position:outside;"><a href="http://link.zhihu.com/?target=http%3A//arxiv.org/abs/1306.0239" rel="nofollow noreferrer" style="box-sizing:inherit;word-break:break-all;color:rgb(34, 85, 153);text-decoration:none;cursor:pointer;border-bottom:0px;" target="_blank">Deep Learning using Linear Support Vector Machines</a>一文的作者是Tang Charlie，论文写于2013年，展示了一些L2SVM比Softmax表现更出色的结果。</li></ul><p style="box-sizing:inherit;margin:20px 0px;"></p><div><b style="box-sizing:inherit;font-weight:700;">线性分类笔记全文翻译完毕</b>。</div></div></div></div></div></div></div></div></div><div><br/></div></div><div><br/></div><div><br/></div></span>
</div></body></html> 